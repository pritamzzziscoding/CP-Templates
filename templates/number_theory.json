{
    "number_theory": {
        "prefix": "number_theory",
        "body": [
            "const int PRIME_MAXN = 1000001;",
            "int prime[PRIME_MAXN];",
            "void eratosthenes(){",
            "    for(int i = 0; i < PRIME_MAXN; i++) prime[i] = 1;",
            "    prime[0] = prime[1] = 0;",
            "    for(int i = 2; i * i < PRIME_MAXN; i++){",
            "        if(prime[i] == 1){",
            "            for(int j = i * i; j < PRIME_MAXN; j += i){",
            "                prime[j] = 0;",
            "            }",
            "        }",
            "    }",
            "}",
            "bool checkprime(int n){",
            "    if(n < 0 || n >= PRIME_MAXN) return false;",
            "    return prime[n];",
            "}",
            "",
            "const int SPF_MAXN = 10000001;",
            "int spf[SPF_MAXN];",
            "void seivespf(){",
            "    iota(spf, spf + SPF_MAXN, 0);",
            "    for(int i = 2; i * i < SPF_MAXN; i++){",
            "        if(spf[i] == i){",
            "            for(int j = i * i; j < SPF_MAXN; j += i){",
            "                if(spf[j] == j) spf[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "// O(log n) using SPF",
            "vector<int> primefactors_spf(int n){",
            "    vector<int> factors;",
            "    while(n > 1){",
            "        factors.push_back(spf[n]);",
            "        n = n / spf[n];",
            "    }",
            "    return factors;",
            "}",
            "",
            "// O(sqrt n) using Trial Division",
            "template<class U>",
            "vector<U> getPrimeFactors(U n){",
            "    vector<U> pf;",
            "    U num = n;",
            "    while (num % 2 == 0) {",
            "        pf.push_back(2);",
            "        num /= 2;",
            "    }",
            "    for (U cpf = 3; cpf * cpf <= num; cpf += 2) {",
            "        while (num % cpf == 0) {",
            "            pf.push_back(cpf);",
            "            num /= cpf;",
            "        }",
            "    }",
            "    if (num > 1) {",
            "        pf.push_back(num);",
            "    }",
            "    return pf;",
            "}",
            "",
            "vector<int> getDivisors(int n){",
            "    vector<int> divisors;",
            "    for(int i = 1; i * i <= n; i++){",
            "        if(n % i == 0){",
            "            divisors.push_back(i);",
            "            if(i * i != n){",
            "                divisors.push_back(n / i);",
            "            }",
            "        }",
            "    }",
            "    sort(divisors.begin(), divisors.end());",
            "    return divisors;",
            "}"
        ],
        "description": "Number Theory (Sieve, SPF, Prime Factors [SPF & Trial], Divisors)"
    }
}